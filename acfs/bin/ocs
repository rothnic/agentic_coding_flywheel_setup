#!/usr/bin/env bash
# ============================================================
# OpenCode Server Manager (ocs)
# Manage OpenCode server instances for shared MCP connections
# ============================================================

set -euo pipefail

OPENCODE_PORT="${OPENCODE_PORT:-4096}"
OPENCODE_LOG_DIR="${OPENCODE_LOG_DIR:-$HOME/.opencode/logs}"
OPENCODE_PID_FILE="$HOME/.opencode/server.pid"

# Colors
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

usage() {
    cat << 'EOF'
OpenCode Server Manager (ocs)

Usage:
  ocs start                    Start OpenCode server in background
  ocs stop                     Stop OpenCode server
  ocs restart                  Restart OpenCode server
  ocs status                   Show server status, connections, and resource usage
  ocs logs                     Tail server logs
  ocs connect                  Connect a new OpenCode client to the running server
  ocs spawn NAME [OPTIONS]     Spawn OpenCode tmux sessions with NTM integration

Spawn Options (follows NTM pattern):
  --oc=N                       Spawn N OpenCode sessions (default agent)
  --oc-architect=N             Spawn N architect agents
  --oc-reviewer=N              Spawn N reviewer agents
  --oc-tester=N                Spawn N tester agents
  --oc-docs=N                  Spawn N documentation agents
  --oc-debugger=N              Spawn N debugger agents

Examples:
  # Start server (like starting cc, cod, or gmi)
  ocs start

  # Check status with resource monitoring
  ocs status

  # Spawn agents (follows NTM --cc=N pattern)
  ocs spawn myproject --oc=2 --oc-architect=1

  # Send commands to all OpenCode agents (NTM syntax)
  ntm send myproject "Analyze this codebase"

  # Send to specific session by name
  ntm send myproject-architect-1 "Review system architecture"

  # Quick launch: server + 3 clients
  ocs quick-start

Interface Philosophy:
  - `ocs` follows agent patterns like `cc`, `cod`, `gmi` for consistency
  - Spawning follows NTM's `--cc=N` flag pattern
  - Use `ntm send` for broadcasting to agents
  - Resource monitoring built-in (CPU, memory for server + clients)

Environment:
  OPENCODE_PORT      Server port (default: 4096)
  OPENCODE_LOG_DIR   Log directory (default: ~/.opencode/logs)

Agent Types:
  - default: General-purpose agent
  - architect: System design and architecture
  - reviewer: Code review and quality checks
  - tester: Test generation and coverage
  - docs: Documentation and comments
  - debugger: Bug hunting and performance

EOF
}

log_info() {
    echo -e "${BLUE}→${NC} $*"
}

log_success() {
    echo -e "${GREEN}✓${NC} $*"
}

log_warn() {
    echo -e "${YELLOW}⚠${NC} $*"
}

log_error() {
    echo -e "${RED}✖${NC} $*" >&2
}

get_server_pid() {
    if [[ -f "$OPENCODE_PID_FILE" ]]; then
        cat "$OPENCODE_PID_FILE"
    fi
}

is_server_running() {
    local pid
    pid=$(get_server_pid)
    if [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null; then
        return 0
    fi
    return 1
}

get_connection_count() {
    # Count active connections to the OpenCode server port
    local count
    count=$(ss -tn 2>/dev/null | grep ":$OPENCODE_PORT" | grep ESTAB | wc -l || echo "0")
    echo "$count"
}

start_server() {
    if is_server_running; then
        log_warn "OpenCode server is already running (PID: $(get_server_pid))"
        return 0
    fi

    log_info "Starting OpenCode server on port $OPENCODE_PORT..."
    
    # Create log directory
    mkdir -p "$OPENCODE_LOG_DIR"
    
    # Start server in background
    local log_file="$OPENCODE_LOG_DIR/server-$(date +%Y%m%d-%H%M%S).log"
    
    nohup opencode serve --port "$OPENCODE_PORT" > "$log_file" 2>&1 &
    local pid=$!
    
    # Save PID
    echo "$pid" > "$OPENCODE_PID_FILE"
    
    # Wait a moment and verify it started
    sleep 2
    if is_server_running; then
        log_success "OpenCode server started (PID: $pid)"
        log_info "Log file: $log_file"
        log_info "Connect with: opencode run --attach http://localhost:$OPENCODE_PORT <prompt>"
    else
        log_error "Failed to start OpenCode server"
        rm -f "$OPENCODE_PID_FILE"
        return 1
    fi
}

stop_server() {
    local pid
    pid=$(get_server_pid)
    
    if [[ -z "$pid" ]]; then
        log_warn "OpenCode server is not running"
        return 0
    fi
    
    if ! kill -0 "$pid" 2>/dev/null; then
        log_warn "OpenCode server PID file exists but process is not running"
        rm -f "$OPENCODE_PID_FILE"
        return 0
    fi
    
    log_info "Stopping OpenCode server (PID: $pid)..."
    kill "$pid" 2>/dev/null || true
    
    # Wait for shutdown (max 5 seconds)
    local count=0
    while kill -0 "$pid" 2>/dev/null && [[ $count -lt 50 ]]; do
        sleep 0.1
        ((count++))
    done
    
    if kill -0 "$pid" 2>/dev/null; then
        log_warn "Server didn't stop gracefully, forcing..."
        kill -9 "$pid" 2>/dev/null || true
    fi
    
    rm -f "$OPENCODE_PID_FILE"
    log_success "OpenCode server stopped"
}

restart_server() {
    stop_server
    sleep 1
    start_server
}

show_status() {
    local pid
    pid=$(get_server_pid)
    
    echo "OpenCode Server Status"
    echo "====================="
    echo ""
    
    if is_server_running; then
        echo -e "Status:      ${GREEN}Running${NC}"
        echo "PID:         $pid"
        echo "Port:        $OPENCODE_PORT"
        echo "URL:         http://localhost:$OPENCODE_PORT"
        
        local conn_count
        conn_count=$(get_connection_count)
        echo "Connections: $conn_count active"
        
        # Show memory usage if ps is available
        if command -v ps &>/dev/null; then
            local mem_usage
            mem_usage=$(ps -o rss= -p "$pid" 2>/dev/null | awk '{print int($1/1024)"MB"}' || echo "N/A")
            echo "Memory:      $mem_usage"
            
            # Show CPU usage
            local cpu_usage
            cpu_usage=$(ps -o %cpu= -p "$pid" 2>/dev/null | tr -d ' ' || echo "N/A")
            echo "CPU:         ${cpu_usage}%"
        fi
        
        # Show uptime
        if command -v ps &>/dev/null; then
            local uptime
            uptime=$(ps -o etime= -p "$pid" 2>/dev/null | tr -d ' ' || echo "N/A")
            echo "Uptime:      $uptime"
        fi
        
        echo ""
        echo "Client Processes:"
        echo "-----------------"
        
        # Find all opencode client processes
        if command -v pgrep &>/dev/null && command -v ps &>/dev/null; then
            local client_pids
            client_pids=$(pgrep -f "opencode run --attach" 2>/dev/null || true)
            
            if [[ -n "$client_pids" ]]; then
                local total_client_mem=0
                local total_client_cpu=0
                local client_count=0
                
                echo "PID      CPU%   MEM(MB)  COMMAND"
                echo "------   ----   -------  -------"
                
                while IFS= read -r cpid; do
                    if [[ -n "$cpid" ]]; then
                        local cmem
                        local ccpu
                        local ccmd
                        cmem=$(ps -o rss= -p "$cpid" 2>/dev/null | awk '{print int($1/1024)}' || echo "0")
                        ccpu=$(ps -o %cpu= -p "$cpid" 2>/dev/null | tr -d ' ' || echo "0")
                        ccmd=$(ps -o comm= -p "$cpid" 2>/dev/null || echo "opencode")
                        
                        printf "%-8s %-6s %-8s %s\n" "$cpid" "$ccpu" "${cmem}MB" "$ccmd"
                        
                        total_client_mem=$((total_client_mem + cmem))
                        total_client_cpu=$(awk "BEGIN {print $total_client_cpu + $ccpu}")
                        ((client_count++))
                    fi
                done <<< "$client_pids"
                
                echo ""
                echo "Total Clients: $client_count"
                echo "Total Client Memory: ${total_client_mem}MB"
                echo "Total Client CPU: ${total_client_cpu}%"
                
                # Combined totals
                local combined_mem=$((mem_usage + total_client_mem))
                local combined_cpu=$(awk "BEGIN {print $cpu_usage + $total_client_cpu}")
                echo ""
                echo "Combined Total (Server + Clients):"
                echo "  Memory: ${combined_mem}MB"
                echo "  CPU: ${combined_cpu}%"
            else
                echo "No active client processes found"
            fi
        else
            echo "Install 'pgrep' and 'ps' for detailed client monitoring"
        fi
    else
        echo -e "Status:      ${RED}Not running${NC}"
        if [[ -f "$OPENCODE_PID_FILE" ]]; then
            echo -e "${YELLOW}Note: Stale PID file exists${NC}"
        fi
    fi
    
    echo ""
    echo "Quick commands:"
    echo "  ocs start              Start the server"
    echo "  oca '<prompt>'         Run a prompt on the server"
    echo "  ocs spawn myproject --oc=2  Spawn 2 OpenCode agents"
}

tail_logs() {
    if [[ ! -d "$OPENCODE_LOG_DIR" ]]; then
        log_error "Log directory does not exist: $OPENCODE_LOG_DIR"
        return 1
    fi
    
    local latest_log
    latest_log=$(ls -t "$OPENCODE_LOG_DIR"/server-*.log 2>/dev/null | head -1)
    
    if [[ -z "$latest_log" ]]; then
        log_error "No log files found in $OPENCODE_LOG_DIR"
        return 1
    fi
    
    log_info "Tailing log: $latest_log"
    tail -f "$latest_log"
}

connect_client() {
    if ! is_server_running; then
        log_error "OpenCode server is not running"
        log_info "Start it with: ocs start"
        return 1
    fi
    
    log_info "Connecting to OpenCode server at http://localhost:$OPENCODE_PORT"
    log_info "Usage: opencode run --attach http://localhost:$OPENCODE_PORT '<your prompt>'"
    
    # Interactive mode if no prompt provided
    exec opencode run --attach "http://localhost:$OPENCODE_PORT"
}

quick_start() {
    log_info "Quick Start: Launching OpenCode server + 3 agent clients in tmux"
    echo ""
    
    # Start server if not running
    if ! is_server_running; then
        start_server || return 1
        sleep 3
    else
        log_info "Server already running"
    fi
    
    # Check if ntm is available
    if ! command -v ntm &>/dev/null; then
        log_error "NTM (Named Tmux Manager) not found"
        log_info "Install with: curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/ntm/main/install.sh | bash"
        return 1
    fi
    
    log_info "Spawning 3 OpenCode clients in tmux sessions..."
    echo ""
    
    # Spawn 3 clients with different roles
    ntm spawn "oc-architect" "echo 'OpenCode Architect Client'; echo 'Use oca command to send prompts'; bash" || true
    ntm spawn "oc-reviewer" "echo 'OpenCode Reviewer Client'; echo 'Use oca command to send prompts'; bash" || true
    ntm spawn "oc-tester" "echo 'OpenCode Tester Client'; echo 'Use oca command to send prompts'; bash" || true
    
    echo ""
    log_success "Quick start complete!"
    echo ""
    echo "Usage:"
    echo "  1. Switch to a session:  ntm attach oc-architect"
    echo "  2. Send a prompt:        oca 'Your prompt here'"
    echo "  3. List all sessions:    ntm list"
    echo "  4. View all clients:     ntm palette"
    echo ""
}

spawn_opencode_sessions() {
    local project_name="$1"
    shift
    
    if [[ -z "$project_name" ]]; then
        log_error "Project name required"
        echo "Usage: ocs spawn PROJECT_NAME [OPTIONS]"
        echo "Example: ocs spawn myproject --oc-architect=2 --oc-reviewer=1"
        return 1
    fi
    
    # Start server if not running
    if ! is_server_running; then
        log_info "Starting OpenCode server..."
        start_server || return 1
        sleep 3
    fi
    
    # Check if ntm is available
    if ! command -v ntm &>/dev/null; then
        log_error "NTM (Named Tmux Manager) not found"
        log_info "Install with: curl -fsSL https://raw.githubusercontent.com/Dicklesworthstone/ntm/main/install.sh | bash"
        return 1
    fi
    
    # Parse agent count options
    local oc_count=0
    local oc_architect_count=0
    local oc_reviewer_count=0
    local oc_tester_count=0
    local oc_docs_count=0
    local oc_debugger_count=0
    
    while [[ $# -gt 0 ]]; do
        case "$1" in
            --oc=*)
                oc_count="${1#*=}"
                ;;
            --oc-architect=*)
                oc_architect_count="${1#*=}"
                ;;
            --oc-reviewer=*)
                oc_reviewer_count="${1#*=}"
                ;;
            --oc-tester=*)
                oc_tester_count="${1#*=}"
                ;;
            --oc-docs=*)
                oc_docs_count="${1#*=}"
                ;;
            --oc-debugger=*)
                oc_debugger_count="${1#*=}"
                ;;
            *)
                log_warn "Unknown option: $1"
                ;;
        esac
        shift
    done
    
    local total_agents=$((oc_count + oc_architect_count + oc_reviewer_count + oc_tester_count + oc_docs_count + oc_debugger_count))
    
    if [[ $total_agents -eq 0 ]]; then
        log_error "No agents specified. Use --oc=N or --oc-TYPE=N"
        echo "Example: ocs spawn myproject --oc=2"
        return 1
    fi
    
    log_info "Spawning $total_agents OpenCode agent(s) for project: $project_name"
    echo ""
    
    # Spawn default agents
    for ((i=1; i<=oc_count; i++)); do
        local session_name="${project_name}-oc-${i}"
        log_info "Creating session: $session_name (default agent)"
        ntm spawn "$session_name" "echo 'OpenCode Agent ${i}'; echo 'Connected to server at http://localhost:$OPENCODE_PORT'; echo 'Use: oca \"your prompt\"'; bash" || true
    done
    
    # Spawn architect agents
    for ((i=1; i<=oc_architect_count; i++)); do
        local session_name="${project_name}-architect-${i}"
        log_info "Creating session: $session_name (architect)"
        ntm spawn "$session_name" "echo 'OpenCode Architect ${i}'; echo 'Role: System design and architecture'; echo 'Use: oca \"your prompt\"'; bash" || true
    done
    
    # Spawn reviewer agents
    for ((i=1; i<=oc_reviewer_count; i++)); do
        local session_name="${project_name}-reviewer-${i}"
        log_info "Creating session: $session_name (reviewer)"
        ntm spawn "$session_name" "echo 'OpenCode Reviewer ${i}'; echo 'Role: Code review and quality'; echo 'Use: oca \"your prompt\"'; bash" || true
    done
    
    # Spawn tester agents
    for ((i=1; i<=oc_tester_count; i++)); do
        local session_name="${project_name}-tester-${i}"
        log_info "Creating session: $session_name (tester)"
        ntm spawn "$session_name" "echo 'OpenCode Tester ${i}'; echo 'Role: Test generation and coverage'; echo 'Use: oca \"your prompt\"'; bash" || true
    done
    
    # Spawn docs agents
    for ((i=1; i<=oc_docs_count; i++)); do
        local session_name="${project_name}-docs-${i}"
        log_info "Creating session: $session_name (documentation)"
        ntm spawn "$session_name" "echo 'OpenCode Docs ${i}'; echo 'Role: Documentation and comments'; echo 'Use: oca \"your prompt\"'; bash" || true
    done
    
    # Spawn debugger agents
    for ((i=1; i<=oc_debugger_count; i++)); do
        local session_name="${project_name}-debugger-${i}"
        log_info "Creating session: $session_name (debugger)"
        ntm spawn "$session_name" "echo 'OpenCode Debugger ${i}'; echo 'Role: Bug hunting and performance'; echo 'Use: oca \"your prompt\"'; bash" || true
    done
    
    echo ""
    log_success "Spawned $total_agents OpenCode agent(s)"
    echo ""
    echo "Using NTM to send commands:"
    echo ""
    echo "Send to ALL agents in project:"
    echo "  ntm send $project_name \"Analyze this codebase\""
    echo ""
    echo "Send to specific session by name:"
    echo "  ntm send ${project_name}-architect-1 \"Focus on architecture\""
    echo "  ntm send ${project_name}-tester-1 \"Generate tests\""
    echo ""
    echo "Note: Sessions are named ${project_name}-TYPE-N"
    echo "      Use exact session names with ntm send"
    echo ""
    echo "List all sessions:"
    echo "  ntm list | grep $project_name"
    echo ""
    echo "Attach to a session:"
    echo "  ntm attach ${project_name}-architect-1"
    echo ""
    echo "Check resource usage:"
    echo "  ocs status"
    echo ""
}

# Parse arguments
CMD="${1:-}"
shift || true

case "$CMD" in
    start)
        start_server
        ;;
    stop)
        stop_server
        ;;
    restart)
        restart_server
        ;;
    status)
        show_status
        ;;
    logs)
        tail_logs
        ;;
    connect)
        connect_client
        ;;
    spawn)
        spawn_opencode_sessions "$@"
        ;;
    quick-start)
        quick_start
        ;;
    --help|-h|help|"")
        usage
        ;;
    *)
        log_error "Unknown command: $CMD"
        echo ""
        usage
        exit 1
        ;;
esac
